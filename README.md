# Assignment Quer Project 2

Group # 27 
Students: Giovanni Tangredi s276086 , Francesco Xia s276509

## Suggested action for compiling and executing the project

execute the following commands:
```bat
make
./bin/main graph_file n query_file [-l] [-q]

options
graph_file = relative or absolute path
n = number of intervals
query_file = relative or absolute path
-l = print generated labels to <add filepath>
-q = print generated query results to <add filepath>
```
for the tests:
```bat
make test_node
./bin/test
```
see makefile for the other rule related to the tests 

## Folder Stucture
``` bash
SDPProjectQ2
├── README.md
├── bin
│   ├── main
│   └── test
├── include
│   ├── bitmap.h
│   ├── constants.h
│   ├── graph.h
│   ├── label.h
│   └── query.h
├── makefile
├── src
│   ├── bitmap.c
│   ├── graph.c
│   ├── label.c
│   ├── main.c
│   └── query.c
└── test
    ├── bitmap_test.c
    ├── graph_test.c
    ├── input 
    │   ├── grafo20.gra
    │   ├── grafo20.png
    │   ├── grafo20_25.que
    │   ├── grafo_con_rango.png
    │   └── large
    │       ├── arXiv_sub_6000-1.gra
    │       ├── cit-Patents.scc.gra
    ├── label_test.c
    ├── node_test.c
    ├── output
    │   └── query_output.txt
    └── query_test.c
```
The src folder contains the source files of the project.
The include folder contains the header files. Note that there is an additional file called constant.h which contains additional settings that the user may change (e.g. possibility to set the constant DEBUG, to have additional infor printed to stdout).
The executable files will be created in the bin folder after the make
The test folder contains the test's source files. At test/input is stored a sample of input files (e.g. a graph and a set of queries). The output are saved to test/output.
The tests were created using the Check.h Framework.

## Program output

The program generates a query_output.txt file that is structured the following way:
for each line source_id destination_id 0/1 unreachable/reachable
This structure is compatible with the output generated by the original implementation of GRAIL.
The program prints the labels to file by passing -l option.
The output file is the following format:
node_id: [l1_l, l1_r] [l2_l] [l2_r] ...

## Data Stuctures 
The graph is represented using a data structure similar to an Adjacency list. A vector of all nodes can be indexed using its node_id. Further more, a node allocated dynamically a vector with the node ids of its children.
The graph stores also the roots nodes.

## Adopted strategies
For the labeling the generation of each label is executed in parallel because each label generation can be executed independently from the others, the only exception is the random shuffle of the root vector, for this purpose each thread create a copy of the root vector. The child vector of each node is the traverse sequentially starting from a random generated index. In this way in the worst case scenario we complexity is reduced from O(label_generation_time*D) to O(max(label-generation_time)).

For the query a similar strategy is used, the queries are divided in 4 equal blocks one for each thread.
