# Project: GRAIL

Group # 27

students: Giovanni Tangredi (s276086), Francesco Xia (s276509)

## Suggested action for compiling and executing the project*
<ins>* this project has been tested on a Linux machine.</ins>

To compile and run the program:
```bat
make
./bin/main <graph_file_path> <num_intervals> <query_file_path> [-l] [-q]

OPTIONS
	-l     saves generated labels to "test/output/labels_out.txt"
	-q     saves query results to "test/output/queries_out.txt"
```


To run the test suites:
```bat
make test_node
./bin/test
```
The other rules available rules are: test_label, test_graph, test_query, test_bitmap

NOTE: <ins>the TEST flag must be set to 0 when the program is executed in normal mode. Otherwise, the labels are not generated randomly.</ins>
Set TEST to 1 when running the test suites.

## Project Stucture
``` bash
SDPProjectQ2
├── README.md
├── bin
├── gen_query.c
├── include
│   ├── bitmap.h
│   ├── constants.h
│   ├── graph.h
│   ├── label.h
│   ├── menu.h
│   ├── query.h
│   └── time_tracker.h
├── makefile
├── src
│   ├── bitmap.c
│   ├── graph.c
│   ├── label.c
│   ├── main.c
│   ├── menu.c
│   ├── query.c
│   └── time_tracker.c
└── test
    ├── input
    │   ├── grafo20.gra
    │   ├── grafo20.png
    │   ├── grafo20_25.que
    │   └── grafo_con_rango.png
    │ 
    │       
    ├── output
    │   ├── labels_out.txt
    │   └── queries_out.txt
    └── tests
        ├── bitmap_test.c
        ├── graph_test.c
        ├── label_test.c
        ├── node_test.c
        └── query_test.c
```
This repository has been divided as follows:
* the **bin folder** contains the executables.
* the **src folder** contains the source files.
* the **test folder** is further divided in:
    * the input folder contains an example of a graph and a set of queries.
    * the output folder contains the output generated by the program (i.e., the labels, the query results, and copy of the graph).
    * the tests folder contains the test source files.
* the **include folder** contains the header files.

The user can customize the program's behavior by modifying the values of the flags in the file *constants.h*:
* DEBUG: verbose mode.
* TEST: if set to one, labels are not randomly generated.
* MAX_THREADS_GRAPH: number of running threads used during the graph generation phase. MUST be > 0.
* MAX_THREADS_QUERY: number of running threads used to solve the queries. MUST be > 0.
* ALL_NODES: flag passed to *graph_print_to_stdout* to print out the nodes on stdout.

The tests were created using the Check.h framework.

## Program output
If the option *-q* is passed, the program creates a file called *queries_out.txt*, where each line represents the result of a query:
*source_id destination_id {0/1}* (unreachable/reachable).

If the option *-q* is missing, the user can interactively query the reachability of two nodes.

Similarly passing the option *-l*, the program creates a file named *labels_out.txt*, with the following format:
*node_id: [l1_l, l1_r] [l2_l, l2_r] ...*

## Data Structures 
The graph is represented using a data structure similar to an adjacency list. Specifically, we used a vector of *Node* pointers to depict the graph. Each node is indexed, through the *node_id*. Furthermore, each node saves:
* a set of node indexes, which replicates the list of its outgoing edges.
* a vector of intervals of size *num_intervals* 

The queries are stored in a static struct called *queries* under query.c
* a single query is represented as a *route* (route.src and route.dst);
* the result of a query is saved as a bit in a bitmap inside *queries*, which state indicates either non-reachability/reachability of the route (0/1). The i-th bit of the bitmap represents the state of i-th query (i.e., the query found at i-th lines of the file <query_file>);

## Adopted strategies
The generation of the graph follows these main ideas:
* the generation is done concurrently by running *MAX_THREADS_GRAPH number* of threads 
* at each iteration, each thread
    * reads *x* lines
    * increment shared counter of read lines (see p_curr_iteration)
    * parse those lines (e.g. find the node_id of the current node and of its children)
    * allocates a single chunk of memory, big enough to store *x* Nodes (see node_create_multiple) 
    * save each created Node at graph->nodes[<node_id>] = node;

repeat until end of file.

The intervals are generated concurrently by running *n* threads, where *n* is equal to the parameter *num_intervals*. The interval generated by i-th thread is saved in the corresponding Node.intervals[i-th];

The label generator is an implementation of the "Algorithm 1: GRAIL Indexing: Randomized Intervals" found in the GRAIL official publication. 

Regarding the queries, they are equally distributed in *n* blocks, where *n* is empirically set to 4 (see constants.h). Each block is then assigned to a thread, which task is to find the non-reachability/reachability of every query of its block.
The query solver is an implementation of the "Algorithm 2: GRAIL Query: Reachability Testing" found in the GRAIL official publication".
